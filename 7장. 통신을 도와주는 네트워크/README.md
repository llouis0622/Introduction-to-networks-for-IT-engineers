# 7장. 통신을 도와주는 네트워크 주요 기술

# 1. NAT(Network Address Translation)/PAT(Port Address Translation)

- 네트워크 주소를 변환하는 기술
- IP 주소를 다른 IP 주소로 변환해 라우팅을 원활히 해주는 기술
- 1:1 변환이 기본, 1:N 변환도 가능
- AFT(Address Family Translation) : IPv4 주소와 IPv6 주소를 상호 변환하는 기술
- 사설 IP 주소에서 공인 IP 주소로 전환

## 1. NAT/PAT의 용도와 필요성

- IPv4 주소 고갈문제의 솔루션으로 NAT 사용
- 보안 강화 → 방향성 통제
- IP 주소 체계가 같은 두 개의 네트워크 간 통신 가능
    - 더블 나트(Double NAT) : IP 대역이 같은 네트워크와 통신할 가능성이 높은 대외계 네트워크를 연결하기 위해 출발지와 도착지를 한꺼번에 변환
- 불필요한 설정 변경 감소
    - 홀 펀칭(Hole Punching) : NAT 밑에 있는 단말 직접 연결

## 2. SNAT와 DNAT

- SNAT(Source NAT) : 출발지 주소를 변경하는 NAT
    - 사설에서 공인으로 통신 : 공유기처럼 PAT 사용
    - 보안 : 변경되는 IP가 반드시 공인일 필요 없음
    - 로드 밸런서 구성
- DNAT(Destination NAT) : 도착지 주소를 변경하는 NAT
    - 로드 밸런서
    - 사내가 아닌 대외망과의 네트워크 구성
- NAT가 수행되기 이전의 트래픽이 출발하는 시작 지점
- 역 NAT : NAT 장비를 처음 통과할 때 NAT 테이블이 생성 → 응답 패킷이 NAT 장비에 들어오면 별도의 NAT 설정이 없더라도 NAT 테이블을 사용해 반대로 패킷 변환

## 3. 동적 NAT와 정적 NAT

- 동적 NAT : 출발지나 목적지 어느 경우든 사전에 정해지지 않고 NAT를 수행할 때 IP를 동적으로 변경
    - 1:N, N:1, N:M 통신
    - NAT 테이블 NAT 수행 시 설정
    - NAT 테이블 타임아웃 동작
    - 실시간으로 확인하거나 별도 변경 로그 저장 필요
- 정적 NAT : 출발지와 목적지의 IP를 미리 매핑해 고정해놓은 NAT
    - 1:1 통신
    - NAT 테이블 사전 생성
    - NAT 테이블 타임아웃 없음
    - 별도 필요 없음 → NAT 내역이 설정

# 2. DNS(Domain Name System)

- 도메인 주소를 IP 주소로 변환
- 데이터 프로토콜 : 실제로 데이터를 실어나르는 것
- 컨트롤 프로토콜 : 데이터 프로토콜이 잘 동작하도록 도와주는 것
- MSA(Micro Service Architecture) 기반 서비스 설계 증가

## 1. DNS 소개

- 하나의 IP 주소를 이용해 여러 개의 웹 서비스 운영
- 서비스 중인 IP 주소 변경 → 도메인 주소 그대로 유지해 접속 방법 변경 없이 서비스 그대로 유지
- 지리적으로 여러 위치에서 서비스 가능
- 인터넷 연결을 위한 DNS와 내부 서비스 간의 이름 풀이와 통신 → 외부와 내부 DNS 분리 운영

## 2. DNS 구조와 명명 규칙

- 최상위 루트부터 Top-Level 도메인, Second-Level 도메인, Third-Level 도메인과 같이 하위 레벨로 원하는 주소를 단계적으로 찾아감
- 각 계층의 경계를 `.` 으로 표시, 뒤에서 앞으로 해석
    
    ```
    www.naver.com.
    www(Third-Level Domain)
    naver(Second-Level Domain)
    com(Top-Level Domain(TLD))
    맨 오른쪽 .(Root, 생략)
    ```
    
- 최대 128계층, 계층별 길이 최대 63바이트, 전체 도메인 네임 길이 최대 255바이트

### 1. 루트 도메인

- 도메인을 구성하는 최상위 영역
    - a.root-servers.net : 198.41.0.4, 2001:503:ba3e::2:30
    - b.root-servers.net : 192.228.79.201, 2001:500:84::b
    - c.root-servers.net : 192.33.4.12, 2001:500:2::c
    - d.root-servers.net : 199.7.91.13, 2001:500:2d::d
    - e.root-servers.net : 192.203.230.10, 2001:500:a8::e
    - f.root-servers.net : 192.5.5.241, 2001:500:2f::f
    - g.root-servers.net : 192.112.36.4, 2001:500:12::d0d
    - h.root-servers.net : 198.97.190.53, 2001:500:1::53
    - i.root-servers.net : 192.36.148.17, 2001:7fe::53
    - j.root-servers.net : 192.58.128.30, 2001:503:c27::2:30
    - k.root-servers.net : 193.0.14.129, 2001:7fd::1
    - l.root-servers.net : 199.7.83.42, 2001:500:9f::42
    - m.root-servers.net : 202.12.27.33, 2001:dc3::35

### 2. Top-Level Domain(TLD)

- Generic TLD(gTLD)
    - 특별한 제한없이 일반적으로 사용되는 최상위 도메인
    - 세 글자 이상으로 구성
    - com : 일반 기업체
    - edu : 4년제 이상 교육기관
    - gov : 미국 연방정부기관
    - int : 국제기구, 기관
    - mil : 미국 연방군사기관
    - net : 네트워크 관련 기관
    - org : 비영리기관
- Country Code TLD(ccTLD)
    - 국가 최상위 도메인
    - 두 글자의 국가 코드 사용
    - kr : 대한민국
- Sponsored(sTLD)
    - 특정 목적을 위한 스폰서를 두고 있는 최상위 도메인
    - 특정 민족공동체, 전문가 집단, 지리적 위치
    - aero, asia, edu, museum 등
- Infrastructure
    - 운용상 중요한 인프라 식별자 공간을 지원하기 위해 전용으로 사용되는 최상위 도메인
    - arpa : 인터넷 안정성을 유지하기 위해 새로운 모든 인프라 하위 도메인이 배치될 도메인 공간 역할
- Generic-restricted(grTLD)
    - 특정 기존을 충족하는 사람이나 단체 사용
    - biz, name, pro
- Test(tTLD)
    - 개발 프로세스에서 테스트 목적으로 사용
    - test

## 3. DNS 동작 방식

- DNS 서버에 도메인 쿼리하는 과정
- DNS 서버없이 로컬에 도메인과 IP 주소를 직접 설정 가능
- hosts 파일 : 로컬에서 도메인과 IP 주소를 관리하는 파일
- 로컬에 있는 DNS 캐시 정보 먼저 확인
- DNS 캐시 정보에 필요한 도메인 정보가 없으면 DNS 서버로 쿼리 수행, DNS 서버로부터 응답 시 결과를 캐시에 먼저 저장
- DNS 기능을 서버에 올리면 DNS 서버는 기본적으로 루트 DNS 관련 정보 보유
- 클라이언트의 쿼리가 자신에게 없는 정보 → 루트 DNS에 쿼리, 루트 DNS → 쿼리한 도메인의 TLD 값 확인 → 해당 TLD 값을 관리하는 DNS가 어디인지 응답
- 재귀적 쿼리(Recursive Query) : 호스트가 DNS 서버에 질의했던 방식
    - 쿼리를 보낸 클라이언트에 서버가 최종 결괏값을 반환
    - 서버 중심 쿼리
    - 클라이언트와 로컬 DNS 간 사용
- 반복적 쿼리(Iterative Query) : DNS 서버가 루트 NS와 TLS NS에 질의한 방식
    - 최종값을 받을 때까지 클라이언트에서 쿼리 계속 진행
    - 로컬 DNS 서버와 상위 DNS 구간에서 사용

## 4. 마스터(Master, Primary)와 슬레이브(Slavem Secondary)

- 마스터 서버
    - 존 파일을 직접 생성, 도메인 관련 정보 관리
    - 도메인 영역 생성 및 레코드 직접 관리
    - 자신이 가진 도메인 정보를 인가받지 않은 다른 DNS 서버가 복제해가지 못하도록 슬레이브 서버 지정해 복제 제한 가능
- 슬레이브 서버
    - 마스터에 만들어진 존 파일 복제
    - 마스터 서버에 설정된 도메인이 가진 레코드값 정기적으로 복제
- 만료 시간(Expiry Time) : 마스터 서버에 문제가 발생하고 일정 시간이 지나면 슬레이브 서버도 도메인에 대한 질의에 정상적으로 응답 불가
- 액티브-스탠바이(Active-Standby) : 두 개의 노드가 동시에 서비스 제공, 한 노드에 문제 발생 시 다른 노드에서 서비스 계속 제공
- 액티브-액티브(Active-Active) : 두 개의 노드 중 액티브 노드만 서비스 제공, 스탠바이 노드 대기 → 액티브 노드에 장애 발생 시 서비스 시작

## 5. DNS 주요 레코드

### 1. A(IPv4) 레코드

- 기본 레코드로 도메인 주소를 IP 주소로 변환하는 레코드
- 동일한 도메인을 가진 A 레코드를 여러 개 만들어 서로 다른 IP 주소와 매핑
- 다수의 도메인에 동일한 IP를 매핑한 A 레코드 제작 가능

### 2. AAAA(IPv6) 레코드

- IPv6 주소 체계에서 사용
- A 레코드와 동일

### 3. CNAME(Canonical Name) 레코드

- 별칭 이름을 사용하게 해주는 레코드
- 도메인 주소 매핑
- www

### 4. SOA(Start Of Authority) 레코드

- 도메인 영역에 대한 권한을 나타내는 레코드
- 현재 도메인 관리에 필요한 속성값 설정
- 도메인 동기화에 필요한 타이머 값 및 TIL 값 설정
- 도메인 네임 서버나 관리자 정보 설정

### 5. NS(Name Server) 레코드

- 도메인에 대한 권한이 있는 네임 서버 정보 설정
- 하위 도메인에 대한 권한을 다른 네임 서버로 위임(Delegate)하는 역할

### 6. MX(Mail eXchange) 레코드

- 메일 서버 구성
- 우선 순위가 높은(값이 적은) 서버로 메일 보냄 → 다음 순서의 MX 레코드의 메일 서버에서 처리

### 7. PTR(Pointer) 레코드

- IP 주소에 대한 질의를 도메인 주소로 응답하기 위한 레코드
- 역방향 조회용 레코드
- 하나의 IP 주소에 대해 하나의 도메인 주소 가짐
- 화이트 도메인 구성

### 8. TXT(TeXT) 레코드

- 도메인에 대한 설명과 같이 간단한 텍스트 입력
- 화이트 도메인을 위한 SPF 레코드
- 공백 포함 가능, 대소문자 구분, 최대 255자

## 6. DNS에서 알아두면 좋은 내용

### 1. 도메인 위임(DNS Delegation)

- 도메인 내의 모든 레코드를 그 네임 서버가 직접 관리하지 않고 일부 영역에 대해서는 다른 곳에서 레코드를 관리하도록 위임
- 자신이 가진 도메인 관리 권한을 다른 곳으로 일부 위임해 위임한 곳에서 세부 레코드를 관리
- 특정 영역에 대한 관리 주체 분리

### 2. TTL(Time To Live)

- DNS에 질의해 응답받는 결괏값을 캐시에서 유지하는 시간
- 서비스의 성질과 도메인 정보의 갱신 빈도에 따라 TTL 값 적절히 조절

### 3. 화이트 도메인

- 정상적인 도메인을 인증, 관리하는 제도
- 불법적인 스팸메일을 발송하는 사이트를 실시간 블랙리스트 정보로 관리 → 메일 발송 제한
- RBL(Realtime Blackhole List, Realtime Blocking List)
- SPF 레코드(Sender Policy Framework) 사전 설정 → 화이트 도메인 등록
    - `-all` : 메일 발송 IP를 위조해 보내온 메일을 수신 메일 서버에서 폐기(Drop)
    - `~all` : 메일 발송 IP를 위조해 보내온 메일을 수신 메일 서버 정책에 따라 결정

### 4. 한글 도메인

- 퓨니코드(Punycode) : 다국어 도메인이 아스키로 변환된 구문
    - 자국어 도메인을 사용할 수 있도록 해주는 표준 코드
    - 다국어 도메인 네임(IDN)

## 7. 호스트 파일 설정

- 도메인과 IP 주소를 매핑해놓은 hosts 파일 이용 → 도메인-IP 주소 쿼리 사용
- 특정 도메인에 대해 임의로 설정한 값으로 도메인 접속
- 사용자의 정보를 빼내기 위한 유해 사이트 접근 유도

# 3. GSLB(Global Server/Service Load Balancing)

- DNS에서 동일한 레코드 이름으로 서로 다른 IP 주소 동시 설정 가능
- 도메인을 이용한 로드 밸런싱 구현
- 도메인 질의에 응답, 등록된 도메인에 연결된 서비스가 정상적인지 헬스 체크
- 인텔리전스 DNS

## 1. GSLB 동작 방식

1. 사용자가 사이트에 접속하기 위해 DNS에 질의
2. LDNS는 사이트를 관리하는 NS 서버를 찾기 위해 root부터 순차 질의
3. 사이트를 관리하는 NS 서버로 사이트에 대해 질의
4. DNS 서버는 GSLB로 사이트에 대해 위임 → GSLB 서버가 NS 서버라고 LDNS에 응답
5. LDNS는 다시 GSLB로 사이트에 대해 질의
6. GSLB는 사이트에 대한 IP 주솟값 중 현재 설정된 분산 방식에 따라 데이터 센터의 IP 주솟값을 DNS에 응답
7. GSLB에서 결괏값을 응답받은 LDNS는 사용자에게 사이트가 1.1.1.1로 서비스하고 있다고 최종 응답

## 2. GSLB 구성 방식

- 도메인 자체를 GSLB로 사용
    - 해당 도메인에 속하는 모든 레코드 설정을 GSLB 장비에서 관리
    - 모든 레코드에 대한 질의가 GSLB를 통해 이루어짐 → GSLB에 부하
- 도메인 내의 특정 레코드만 GSLB를 사용
    - DNS에서 도메인 설정 시 GSLB를 사용하려는 레코드에 대해서만 GSLB로 처리하도록 설정
    - 별칭(Alias) 사용(CNAME 레코드 사용)
        - 실제 도메인과 다른 별도의 도메인 레코드로 GSLB에 등록
        - CDN처럼 GSLB를 운영해주는 외부 사업자가 있거나 GSLB를 사용해아 하는 도메인이 매우 많은 경우
    - 위임(Delegation) 사용(NS 레코드 사용)
        - 실제 도메인과 동일한 도메인 레코드를 사용, 도메인 전체 위임
        - DNS와 같은 도메인으로 GSLB를 운영하면서 계층적으로 GSLB를 이용한 FQDN을 관리

## 3. GSLB 분산 방식

- 라운드 로빈(Round Robin), 최소 접속(Least Connection), 해싱(Hashing)
- 서비스 제공의 가능 여부를 체크해 트래픽 분산
- 지리적으로 멀리 떨어진 다른 데이터 센터에 트래픽 분산
- 지역적으로 가까운 서비스에 접속해 더 빠른 서비스 제공이 가능하도록 분산
- 서비스 응답 시간/지연(RTT/Latency) : 서비스 요청에 대한 응답이 얼마나 빠른지 또는 지연이 얼마나 없는지를 확인하고 이것을 이용해 서비스 분산 처리
- IP에 대한 지리(Geography) 정보 : 서비스 제공이 가능한 각 사이트의 IP 주소에 대한 Geo 값을 확인해 가까운 사이트로 서비스 분산 처리

# 4. DHCP(Dynamic Host Configuration Protocol)

- IP를 동적으로 할당하는 데 사용되는 프로토콜
    - 정적 할당 : 수동으로 IP와 네트워크 정보를 직접 설정하는 것
    - 동적 할당 : 자동으로 설정
- IP 주소, 서브넷 마스크, 게이트웨이, DNS 정보를 자동으로 할당받아 사용

## 1. DHCP 프로토콜

- BOOTP(Bootstrap Protocol) 프로토콜 기반
- BOOTP + BOOTP에서 지원되지 않는 몇 가지 기능 추가
- 클라이언트 서비스 포트 : 68(bootpc)
- 서버 서비스 포트 : 67(bootps)

## 2. DHCP 동작 방식

1. DHCP Discover
    - DHCP 클라이언트는 DHCP 서버를 찾기 위해 DHCP Discover 메시지를 브로드캐스트로 전송
2. DHCP Offer
    - DHCP Discover를 수신한 DHCP 서버는 클라이언트에 할당할 IP 주소와 서브넷, 게이트웨이, DNS 정보, Lease Time 등의 정보를 포함한 DHCP 메시지를 클라이언트로 전송
3. DHCP Request
    - DHCP 서버로부터 제안받은 IP 주소(Requested IP)와 DHCP 서버 정보(DHCP Server Identifier)를 포함한 DHCP 요청 메시지를 브로드캐스트로 전송
4. DHCP Acknowledgement
    - DHCP 클라이언트로부터 IP 주소를 사용하겠다는 요청을 받으면 DHCP 서버에 해당 IP를 어떤 클라이언트가 언제부터 사용하기 시작했는지 정보 기록, DHCP Request 메시지를 정상적으로 수행했다는 응답 전송
- DHCP 메시지 타입
    - DHCP Discover : 클라이언트가 사용한 DHCP 서버를 찾는 메시지
    - DHCP Offer : DHCP 서버가 IP 설정값에 대해 클라이언트에게 제안하는 메시지
    - DHCP Request : DHCP 서버에서 제안받은 설정값을 요청하는 메시지
    - DHCP Decline : 현재 IP가 사용 중임을 클라이언트가 서버에 알려주는 메시지
    - DHCP Ack : DHCP 서버가 클라이언트에 받은 요청을 수락하는 메시지
    - DHCP Nak : DHCP 서버가 클라이언트에 받은 요청을 수락하지 않는다는 메시지
    - DHCP Release : 클라이언트가 현재 IP를 반납할 때 사용하는 메시지
    - DHCP Inform : 클라이언트가 서버에 IP 설정값을 요청하는 메시지
- DHCP Starvation 공격 : DHCP 서버에서 가용한 모든 IP를 가짜로 할당받아 실제 클라이언트가 IP 주소를 할당받지 못하게 하는 공격 방식

## 3. DHCP 서버 구성

- IP 주소 풀(IP 범위) : 클라이언트에 할당할 IP 주소 범위
- 예외 IP 주소 풀(예외 IP 범위) : 클라이언트에 할당할 IP 주소로 선언된 범위 중 예외적으로 할당하지 않을 대역
- 임대 시간 : 클라이언트에 할당할 IP 주소의 기본 임대 시간
- 서브넷 마스크 : 클라이언트에 할당할 IP 주소에 대한 서브넷 마스크 정보
- 게이트웨이 : 클라이언트에 할당할 게이트웨이 정보
- DNS : 클라이언트에 할당할 DNS 정보

## 4. DHCP 릴레이

- DHCP 서버 한 대로 여러 네트워크 대역에서 IP 풀 관리 가능
1. DHCP Discover(클라이언트 → 릴레이 에이전트)
    - DHCP 클라이언트는 DHCP 서버를 찾기 위해 브로드캐스트로 패킷 전송
2. DHCP Discover(릴레이 에이전트 → DHCP 서버)
    - DHCP 릴레이 에이전트는 클라이언트가 보낸 DHCP Discover 메시지를 다른 네트워크에 있는 DHCP 서버로 전달하기 위해 출발지와 목적지를 릴레이 에이전트 IP 주소와 DHCP 서버 IP 주소로 재작성
3. DHCP Offer(DHCP 서버 → 릴레이 에이전트)
    - DHCP Discover를 수신한 DHCP 서버는 클라이언트에 할당할 IP 주소와 서브넷, 게이트웨이, DNS 정보, 임대 시간 등의 정보를 포함한 DHCP 메시지를 DHCP 릴레이 에이전트로 재전송
4. DHCP Offer(릴레이 에이전트 → 클라이언트)
    - DHCP 릴레이 에이전트는 DHCP Offer 메시지를 DHCP 클라이언트에 브로드캐스트로 재전송 → DHCP 메시지 내의 다른 값은 모두 동일하게 전송, DHCP Server Identifier는 실제 DHCP 서버의 IP 주소에서 릴레이 에이전트의 외부 인터페이스 IP로 변경되어 전송
5. DHCP Request(클라이언트 → 릴레이 에이전트)
    - DHCP 클라이언트는 DHCP 서버로부터 제안받은 IP 주소와 DHCP 서버 정보를 포함한 DHCP 요청 메시지를 브로드캐스트로 전송
6. DHCP Request(릴레이 에이전트 → DHCP 서버)
    - DHCP 클라이언트에서 보낸 DHCP 요청 메시지를 유니캐스트로 다시 변환해 DHCP 서버로 전달
7. DHCP ACK(DHCP 서버 → 릴레이 에이전트)
    - DHCP 요청을 받은 DHCP 서버는 해당 IP를 어떤 클라이언트가 언제부터 사용하기 시작했는지 정보 기록, DHCP Request 메시지를 정상적으로 수신했다는 응답 전송 → 유니캐스트 형태
8. DHCP ACK(릴레이 에이전트 → 클라이언트)
    - DHCP 서버에서 받은 Ack 메시지를 클라이언트에 브로드캐스트로 재전달
